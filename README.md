# Course - DSA

## Questions:

_Date: 18/07/19_

1. Given a binary text and a pattern, search the number of times that pattern occurs in that string using hashing.
Repeat the above questions for alphabets as input, alphabets in all cases and alphanumeric input.

2. Given two binary strings and an integral value denoting the length, find if a pattern of the given length exists in both of the strings or not?
|string1| + |string2| <= 1000000

3. Given two binary strings, find the length of the longest pattern present in both the strings.

_Date: 19/07/19_

1. Given an array, create another array which contains the index such that:
* The index is as minimum as possible
* Value at that index >= Value at current index for each valid index in the array.

  For the last element in the array, store the size of the array.

  * Sample Input:
    11
    48 93 12 748 63 7 4 73 98 64 41

  * Sample Output:
    1 3 3 11 7 7 7 8 11 11 11

2. Input a tree and print all possible traversals of the tree
3. Build a tree having the same Inorder traversal as of the given tree.
4. Build a tree having the same Preorder traversal as of the given tree.
5. Build a tree having the same Postorder traversal as of the given tree.
6. Build a tree out of the given Preorder and Inorder traversals.
7. Build a tree out of the given Postorder and Inorder traversals.

_Date: 22/07/19_

1. Implement preorder traversal in a binary tree using user stack.
2. Implement inorder traversal in a binary tree using user stack.
3. Implement postorder traversal in a binary tree using user stack.
4. Find the level of all nodes in a tree.
5. Find the maximum height of the tree.
6. Find the level order traversal in a binary tree.
7. Find the level ordering number in a binary tree.
8. Create a binary search tree and add the fucntionality to:
   * Add a node
   * Search a node
   * Delete a node
   in that tree.
9. Given a BST, find the predecessor of the input node in that tree. Predecessor is the node with the largest value, smaller that the input node.
10. Given a BST, find the successor of the input node in that tree. Successor is the node with the smallest value, larger that the input node.
11. Given a BST and two integers, L denoting the lower limit and U denoting the upper limit, find all the elements in the BST falling in the given range.

_Date: 24/07/19_

1. Implement mergesort
2. Implement ramdomized quicksort
3. Rank(r) of a number = 1 + number of elements strictly greater than that number. Given an unsorted array with distinct elements and a rank R, find the element with rank R.  
